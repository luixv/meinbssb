<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ZMI Server Ping Monitoring Dashboard</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.2/dist/chart.umd.min.js"></script>
    <style>
        :root {
            --color-green: #28a745;
            --color-orange: #fd7e14;
            --color-red: #dc3545;
            --color-bg: #121212;
            --color-surface: #1e1e1e;
            --color-text-primary: #e0e0e0;
            --color-text-secondary: #a0a0a0;
            --color-border: #333;
            --color-table-header-bg: #343a40;
            --color-table-row-even: #252525;
            --color-table-row-hover: #3a3a3a;
            --color-button-bg: #007bff;
            --color-button-hover: #0056b3;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            background-color: var(--color-bg);
            color: var(--color-text-primary);
            padding: 20px;
            box-sizing: border-box;
            line-height: 1.6;
        }
        .container {
            background-color: var(--color-surface);
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            max-width: 95%; /* Increased max-width for charts */
            margin: 20px auto;
            overflow-x: hidden; /* Prevent horizontal scroll on container itself */
        }
        h1 {
            color: var(--color-text-primary);
            text-align: center;
            margin-bottom: 10px;
        }
        .target-url-display {
            font-size: 1.1em;
            color: var(--color-text-secondary);
            text-align: center;
            margin-bottom: 20px;
        }

        /* Chart Styles */
        .chart-container {
            display: flex;
            flex-wrap: wrap; /* Allow charts to wrap on smaller screens */
            gap: 20px;
            justify-content: center;
            margin-bottom: 40px;
            padding-bottom: 20px;
            border-bottom: 1px solid var(--color-border);
        }
        .chart-wrapper {
            flex: 1 1 calc(50% - 20px); /* Two columns, responsive */
            min-width: 300px; /* Minimum width for charts */
            max-width: 500px; /* Max width to prevent charts from becoming too wide */
            background-color: #6a6a6a; /* Slightly lighter background for chart areas */
            padding: 15px;
            border-radius: 8px;
            box-shadow: inset 0 0 5px rgba(0,0,0,0.2);
        }
        @media (max-width: 768px) {
            .chart-wrapper {
                flex: 1 1 100%; /* Single column on small screens */
            }
        }
        canvas {
            max-width: 100% !important; /* Override Chart.js inline styles */
            height: auto !important;
        }

        /* Toggle Button */
        .toggle-button-container {
            text-align: center;
            margin: 20px 0;
        }
        .toggle-button {
            background-color: var(--color-button-bg);
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.3s ease;
        }
        .toggle-button:hover {
            background-color: var(--color-button-hover);
        }

        /* Table Styles */
        #monitorTableContainer {
            margin-top: 20px;
            overflow-x: auto; /* For responsive tables */
            /* Initially hidden, JS will toggle this */
            display: none;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            min-width: 700px; /* Ensure table doesn't get too small */
        }
        th, td {
            border: 1px solid var(--color-border);
            padding: 12px 15px;
            text-align: left;
            vertical-align: top;
            white-space: nowrap; /* Prevent wrapping in cells */
        }
        th {
            background-color: var(--color-table-header-bg);
            color: white;
            font-weight: 600;
            position: sticky; /* Make header sticky when scrolling */
            top: 0;
            z-index: 1;
        }
        tbody tr:nth-child(even) { background-color: var(--color-table-row-even); }
        tbody tr:hover { background-color: var(--color-table-row-hover); }

        /* Status colors */
        .status-online { color: var(--color-green); font-weight: bold; }
        .status-slow_response { color: var(--color-orange); font-weight: bold; }
        .status-http_code_mismatch { color: var(--color-red); font-weight: bold; }
        .status-server_timeout { color: var(--color-red); font-weight: bold; }
        .status-curl_error { color: var(--color-red); font-weight: bold; }
        
        /* Curl Error Types - All in red but with different shades for distinction */
        .status-curl_operation_timed_out { color: #dc3545; font-weight: bold; }
        .status-curl_could_not_connect { color: #c82333; font-weight: bold; }
        .status-curl_could_not_resolve_host { color: #bd2130; font-weight: bold; }
        .status-curl_ssl_connect_error { color: #a71e2a; font-weight: bold; }
        .status-curl_operation_timeout { color: #dc3545; font-weight: bold; }
        .status-curl_ssl_certificate_problem { color: #a71e2a; font-weight: bold; }
        .status-curl_ssl_certificate_verify_failed { color: #a71e2a; font-weight: bold; }
        .status-curl_peer_failed_verification { color: #a71e2a; font-weight: bold; }
        .status-curl_http_returned_error { color: #c82333; font-weight: bold; }
        .status-curl_remote_access_denied { color: #c82333; font-weight: bold; }
        .status-curl_got_nothing { color: #bd2130; font-weight: bold; }
        .status-curl_partial_file { color: #fd7e14; font-weight: bold; }
        .status-curl_upload_failed { color: #c82333; font-weight: bold; }
        .status-curl_read_error { color: #c82333; font-weight: bold; }
        .status-curl_write_error { color: #c82333; font-weight: bold; }
        .status-curl_send_error { color: #c82333; font-weight: bold; }
        .status-curl_recv_error { color: #c82333; font-weight: bold; }
        .status-curl_out_of_memory { color: #6c757d; font-weight: bold; }
        .status-curl_too_many_redirects { color: #fd7e14; font-weight: bold; }
        .status-curl_again { color: #fd7e14; font-weight: bold; }
        .status-curl_aborted_by_callback { color: #6c757d; font-weight: bold; }
        .status-curl_bad_function_argument { color: #6c757d; font-weight: bold; }
        .status-curl_interface_failed { color: #c82333; font-weight: bold; }
        .status-curl_unknown_option { color: #6c757d; font-weight: bold; }
        .status-curl_bad_option { color: #6c757d; font-weight: bold; }
        .status-curl_url_malformed { color: #6c757d; font-weight: bold; }
        .status-curl_url_user_required { color: #6c757d; font-weight: bold; }
        .status-curl_could_not_resolve_proxy { color: #bd2130; font-weight: bold; }
        .status-curl_ftp_weird_server_reply { color: #fd7e14; font-weight: bold; }
        .status-curl_ftp_accept_failed { color: #fd7e14; font-weight: bold; }
        .status-curl_ftp_weird_pass_reply { color: #fd7e14; font-weight: bold; }
        .status-curl_ftp_accept_timeout { color: #dc3545; font-weight: bold; }
        .status-curl_ftp_weird_pasv_reply { color: #fd7e14; font-weight: bold; }
        .status-curl_ftp_weird_227_format { color: #fd7e14; font-weight: bold; }
        .status-curl_ftp_cant_get_host { color: #bd2130; font-weight: bold; }
        .status-curl_http2_error { color: #c82333; font-weight: bold; }
        .status-curl_ftp_could_not_set_type { color: #fd7e14; font-weight: bold; }
        .status-curl_ftp_could_not_retr_file { color: #fd7e14; font-weight: bold; }
        .status-curl_quote_error { color: #fd7e14; font-weight: bold; }
        .status-curl_bad_download_resume { color: #fd7e14; font-weight: bold; }
        .status-curl_file_could_not_read_file { color: #6c757d; font-weight: bold; }
        .status-curl_ldap_cannot_bind { color: #c82333; font-weight: bold; }
        .status-curl_ldap_search_failed { color: #c82333; font-weight: bold; }
        .status-curl_library_not_found { color: #6c757d; font-weight: bold; }
        .status-curl_function_not_found { color: #6c757d; font-weight: bold; }
        .status-curl_ssl_cipher { color: #a71e2a; font-weight: bold; }
        .status-curl_range_error { color: #c82333; font-weight: bold; }
        .status-curl_http_post_error { color: #c82333; font-weight: bold; }
        .status-curl_ssl_engine_not_found { color: #a71e2a; font-weight: bold; }
        .status-curl_ssl_engine_set_failed { color: #a71e2a; font-weight: bold; }
        .status-curl_ssl_shutdown_failed { color: #a71e2a; font-weight: bold; }
        .status-curl_ssl_crl_badfile { color: #a71e2a; font-weight: bold; }
        .status-curl_ssl_issuer_error { color: #a71e2a; font-weight: bold; }
        .status-curl_ftp_pret_failed { color: #fd7e14; font-weight: bold; }
        .status-curl_rtsp_cseq_error { color: #c82333; font-weight: bold; }
        .status-curl_rtsp_session_error { color: #c82333; font-weight: bold; }
        .status-curl_ftp_bad_file_list { color: #fd7e14; font-weight: bold; }
        .status-curl_chunk_failed { color: #c82333; font-weight: bold; }
        .status-curl_no_connection_available { color: #bd2130; font-weight: bold; }
        .status-curl_ssl_pinned_pubkey_not_match { color: #a71e2a; font-weight: bold; }
        .status-curl_ssl_invalid_certificate_status { color: #a71e2a; font-weight: bold; }
        .status-curl_http2_stream { color: #c82333; font-weight: bold; }
        .status-curl_recursive_api_call { color: #6c757d; font-weight: bold; }
        .status-curl_auth_error { color: #c82333; font-weight: bold; }
        .status-curl_http3 { color: #c82333; font-weight: bold; }
        .status-curl_quic_connect_error { color: #c82333; font-weight: bold; }
        .status-curl_proxy { color: #c82333; font-weight: bold; }
        .status-curl_ssl_client_cert { color: #a71e2a; font-weight: bold; }
        .status-curl_unrecoverable_proxy { color: #c82333; font-weight: bold; }
        .status-curl_ssl_engine_init_failed { color: #a71e2a; font-weight: bold; }
        .status-curl_login_denied { color: #c82333; font-weight: bold; }
        .status-curl_tftp_not_found { color: #c82333; font-weight: bold; }
        .status-curl_tftp_perm { color: #c82333; font-weight: bold; }
        .status-curl_remote_disk_full { color: #c82333; font-weight: bold; }
        .status-curl_tftp_illegal { color: #c82333; font-weight: bold; }
        .status-curl_tftp_unknown_id { color: #c82333; font-weight: bold; }
        .status-curl_remote_file_exists { color: #c82333; font-weight: bold; }
        .status-curl_tftp_no_such_user { color: #c82333; font-weight: bold; }
        .status-curl_conversion_failed { color: #6c757d; font-weight: bold; }
        .status-curl_conversion_required { color: #6c757d; font-weight: bold; }
        .status-curl_ssl_cacert_badfile { color: #a71e2a; font-weight: bold; }
        .status-curl_remote_file_not_found { color: #c82333; font-weight: bold; }
        .status-curl_ssh { color: #c82333; font-weight: bold; }
        
        /* Generic curl error fallback */
        .status-curl_unknown_error_* { color: #6c757d; font-weight: bold; }

        .loading-message, .error-message {
            text-align: center;
            padding: 20px;
            color: var(--color-text-secondary);
        }
        .error-message { color: var(--color-red); }
        .last-update-info {
            font-size: 0.8em;
            color: var(--color-text-secondary);
            text-align: right;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ZMI Server Monitoring Dashboard</h1>
        <p class="target-url-display">Monitoring: <a id="monitoredUrl" href="https://webintern.bssb.bayern:56400/rest/zmi/api/serverping" target="_blank">https://webintern.bssb.bayern:56400/rest/zmi/api/serverping</a></p>

        <div id="loading" class="loading-message">Loading data...</div>
        <div id="error" class="error-message" style="display: none;"></div>

        <div class="chart-container">
            <div class="chart-wrapper">
                <canvas id="responseTimeChart"></canvas>
            </div>
            <div class="chart-wrapper">
                <canvas id="statusDistributionChart"></canvas>
            </div>
        </div>

        <div class="toggle-button-container">
            <button id="toggleTableBtn" class="toggle-button">Show Table</button>
        </div>

        <div id="monitorTableContainer">
            <table id="monitorTable">
                <thead>
                    <tr>
                        <th>Timestamp</th>
                        <th>Target URL</th>
                        <th>HTTP Code</th>
                        <th>Response Time (s)</th>
                        <th>Status</th>
                    </tr>
                </thead>
                <tbody>
                    </tbody>
            </table>
        </div>
        <div id="lastUpdate" class="last-update-info"></div>
    </div>

    <script>
        const CSV_FILE_PATH = 'https_monitor.csv';
        const MAX_ROWS_TO_DISPLAY = 200; // Max rows for table and chart data points

        // Chart instances (will be initialized after data fetch)
        let responseTimeChart;
        let statusDistributionChart;

        // Function to create/update the Response Time Line Chart
        function updateResponseTimeChart(timestamps, responseTimes) {
            const ctx = document.getElementById('responseTimeChart').getContext('2d');
            const data = {
                labels: timestamps,
                datasets: [{
                    label: 'Response Time (s)',
                    data: responseTimes,
                    borderColor: 'rgb(75, 192, 192)',
                    tension: 0.1,
                    fill: false,
                    pointRadius: 3,
                    pointHoverRadius: 5
                }]
            };
            const options = {
                responsive: true,
                maintainAspectRatio: true,
                plugins: {
                    title: {
                        display: true,
                        text: 'Response Time Trend (Last ' + timestamps.length + ' checks)',
                        color: 'var(--color-text-primary)'
                    },
                    legend: {
                        labels: {
                            color: 'var(--color-text-secondary)'
                        }
                    }
                },
                scales: {
                    x: {
                        ticks: {
                            color: 'var(--color-text-secondary)',
                            autoSkip: true, // Automatically skip labels if too many
                            maxRotation: 45, // Rotate labels for readability
                            minRotation: 45,
                            maxTicksLimit: 10, // Limit the number of ticks
                            callback: function(val, index) {
                                // Show only the time for better readability
                                return this.getLabelForValue(val).split(' ')[1];
                            }
                        },
                        grid: {
                            color: 'var(--color-border)'
                        }
                    },
                    y: {
                        ticks: {
                            color: 'var(--color-text-secondary)'
                        },
                        grid: {
                            color: 'var(--color-border)'
                        },
                        title: {
                            display: true,
                            text: 'Seconds',
                            color: 'var(--color-text-secondary)'
                        }
                    }
                }
            };

            if (responseTimeChart) {
                responseTimeChart.data = data;
                responseTimeChart.options = options; // Update options if needed
                responseTimeChart.update();
            } else {
                responseTimeChart = new Chart(ctx, {
                    type: 'line',
                    data: data,
                    options: options
                });
            }
        }

        // Function to create/update the Status Distribution Doughnut Chart
        function updateStatusDistributionChart(statusCounts) {
            const ctx = document.getElementById('statusDistributionChart').getContext('2d');
            const labels = Object.keys(statusCounts);
            const dataValues = Object.values(statusCounts);
            
            // Create display labels mapping
            const displayLabels = labels.map(label => {
                switch (label) {
                    case 'offline': return 'Offline';
                    case 'online': return 'Online';
                    case 'slow_response': return 'Slow Response';
                    case 'http_code_mismatch': return 'HTTP Code Mismatch';
                    case 'server_timeout': return 'Server Timeout';
                    default: return label.charAt(0).toUpperCase() + label.slice(1).replace(/_/g, ' ');
                }
            });
            
            const backgroundColors = labels.map(label => {
                const normalizedLabel = label.toLowerCase();
                
                switch (normalizedLabel) {
                    case 'online': 
                        return '#1e7e34'; // Darker Green
                    case 'slow_response': 
                        return '#fd7e14'; // Orange
                    case 'http_code_mismatch':
                        return '#dc3545'; // Red
                    
                    // Server timeout (bright red)
                    case 'server_timeout':
                        return '#dc3545'; // Bright Red
                    
                    // Offline status (bright red) - replaces curl_error
                    case 'offline':
                        return '#dc3545'; // Bright Red
                    
                    // Generic curl error (bright red)
                    case 'curl_error':
                        return '#dc3545'; // Bright Red
                    
                    // Timeout errors (bright red)
                    case 'curl_operation_timed_out':
                    case 'curl_operation_timeout':
                    case 'curl_ftp_accept_timeout':
                        return '#dc3545'; // Bright Red
                    
                    // Connection errors (dark red)
                    case 'curl_could_not_connect':
                    case 'curl_could_not_resolve_host':
                    case 'curl_could_not_resolve_proxy':
                    case 'curl_no_connection_available':
                    case 'curl_got_nothing':
                        return '#c82333'; // Dark Red
                    
                    // SSL/Certificate errors (very dark red)
                    case 'curl_ssl_connect_error':
                    case 'curl_ssl_certificate_problem':
                    case 'curl_ssl_certificate_verify_failed':
                    case 'curl_peer_failed_verification':
                    case 'curl_ssl_cipher':
                    case 'curl_ssl_engine_not_found':
                    case 'curl_ssl_engine_set_failed':
                    case 'curl_ssl_shutdown_failed':
                    case 'curl_ssl_crl_badfile':
                    case 'curl_ssl_issuer_error':
                    case 'curl_ssl_pinned_pubkey_not_match':
                    case 'curl_ssl_invalid_certificate_status':
                    case 'curl_ssl_client_cert':
                    case 'curl_ssl_engine_init_failed':
                    case 'curl_ssl_cacert_badfile':
                        return '#a71e2a'; // Very Dark Red
                    
                    // HTTP/Server errors (medium red)
                    case 'curl_http_returned_error':
                    case 'curl_remote_access_denied':
                    case 'curl_upload_failed':
                    case 'curl_read_error':
                    case 'curl_write_error':
                    case 'curl_send_error':
                    case 'curl_recv_error':
                    case 'curl_interface_failed':
                    case 'curl_range_error':
                    case 'curl_http_post_error':
                    case 'curl_ldap_cannot_bind':
                    case 'curl_ldap_search_failed':
                    case 'curl_rtsp_cseq_error':
                    case 'curl_rtsp_session_error':
                    case 'curl_chunk_failed':
                    case 'curl_http2_stream':
                    case 'curl_auth_error':
                    case 'curl_http3':
                    case 'curl_quic_connect_error':
                    case 'curl_proxy':
                    case 'curl_unrecoverable_proxy':
                    case 'curl_login_denied':
                    case 'curl_tftp_not_found':
                    case 'curl_tftp_perm':
                    case 'curl_remote_disk_full':
                    case 'curl_tftp_illegal':
                    case 'curl_tftp_unknown_id':
                    case 'curl_remote_file_exists':
                    case 'curl_tftp_no_such_user':
                    case 'curl_remote_file_not_found':
                    case 'curl_ssh':
                        return '#c82333'; // Medium Red
                    
                    // FTP errors (orange)
                    case 'curl_ftp_weird_server_reply':
                    case 'curl_ftp_accept_failed':
                    case 'curl_ftp_weird_pass_reply':
                    case 'curl_ftp_weird_pasv_reply':
                    case 'curl_ftp_weird_227_format':
                    case 'curl_ftp_could_not_set_type':
                    case 'curl_ftp_could_not_retr_file':
                    case 'curl_quote_error':
                    case 'curl_bad_download_resume':
                    case 'curl_ftp_pret_failed':
                    case 'curl_ftp_bad_file_list':
                        return '#fd7e14'; // Orange
                    
                    // Configuration/System errors (grey)
                    case 'curl_out_of_memory':
                    case 'curl_aborted_by_callback':
                    case 'curl_bad_function_argument':
                    case 'curl_unknown_option':
                    case 'curl_bad_option':
                    case 'curl_url_malformed':
                    case 'curl_url_user_required':
                    case 'curl_file_could_not_read_file':
                    case 'curl_library_not_found':
                    case 'curl_function_not_found':
                    case 'curl_recursive_api_call':
                    case 'curl_conversion_failed':
                    case 'curl_conversion_required':
                        return '#6c757d'; // Grey
                    
                    // Retry/Partial errors (light orange)
                    case 'curl_partial_file':
                    case 'curl_too_many_redirects':
                    case 'curl_again':
                        return '#fd7e14'; // Light Orange
                    
                    // Default for any other curl errors
                    default:
                        if (normalizedLabel.startsWith('curl_')) {
                            return '#6c757d'; // Grey for unknown curl errors
                        }
                        return '#6c757d'; // Grey for unknown
                }
            });

            const data = {
                labels: displayLabels, // Use display labels instead of raw labels
                datasets: [{
                    data: dataValues,
                    backgroundColor: backgroundColors,
                    borderColor: '#000000', // Black border for perimeter
                    borderWidth: 1,
                    hoverOffset: 4
                }]
            };
            const options = {
                responsive: true,
                maintainAspectRatio: true,
                cutout: '60%',
                plugins: {
                    title: {
                        display: true,
                        text: 'Status Distribution',
                        color: 'var(--color-text-primary)'
                    },
                    legend: {
                        position: 'bottom',
                        labels: {
                            color: 'var(--color-text-secondary)',
                            usePointStyle: true,
                            padding: 20
                        }
                    }
                },
                elements: {
                    arc: {
                        borderWidth: 2
                    }
                }
            };

            if (statusDistributionChart) {
                statusDistributionChart.data = data;
                statusDistributionChart.options = options; // Update options if needed
                statusDistributionChart.update();
            } else {
                statusDistributionChart = new Chart(ctx, {
                    type: 'doughnut',
                    data: data,
                    options: options
                });
            }
        }

        async function fetchData() {
            document.getElementById('loading').style.display = 'block';
            document.getElementById('error').style.display = 'none';

            try {
                const response = await fetch(CSV_FILE_PATH + '?' + new Date().getTime()); // Add cache-buster
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status} - Could not load CSV.`);
                }
                const csvText = await response.text();
                parseAndDisplayData(csvText);
            } catch (e) {
                console.error("Failed to fetch CSV:", e);
                document.getElementById('error').textContent = `Failed to load data: ${e.message}. Ensure '${CSV_FILE_PATH}' exists and is readable by the web server.`;
                document.getElementById('error').style.display = 'block';
                document.getElementById('loading').style.display = 'none';
            }
        }

        function parseAndDisplayData(csvText) {
            try {
                const lines = csvText.trim().split('\n');
                const tableBody = document.getElementById('monitorTable').getElementsByTagName('tbody')[0];
                tableBody.innerHTML = ''; // Clear existing rows

                if (lines.length <= 1) { // Only header or empty file
                    tableBody.innerHTML = '<tr><td colspan="5" style="text-align: center;">No data available yet.</td></tr>';
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('lastUpdate').textContent = `Last updated: ${new Date().toLocaleString()}`;
                    // Clear charts if no data
                    if (responseTimeChart) responseTimeChart.destroy();
                    if (statusDistributionChart) statusDistributionChart.destroy();
                    responseTimeChart = null;
                    statusDistributionChart = null;
                    return;
                }

                const dataLines = lines.slice(1); // Skip header row
                // Take the last N entries for both table and charts
                const relevantData = dataLines.slice(Math.max(0, dataLines.length - MAX_ROWS_TO_DISPLAY));

                // Prepare data for charts
                const timestamps = [];
                const responseTimes = [];
                const statusCounts = {};

                relevantData.forEach(line => {
                    const columns = line.split(',');
                    if (columns.length === 5) {
                        // For charts (reversed to show oldest on left for line chart)
                        timestamps.push(columns[0]);
                        responseTimes.push(parseFloat(columns[3]));

                        // For status distribution - display "Offline" instead of "curl_error"
                        let status = columns[4];
                        if (status.toLowerCase() === 'curl_error') {
                            status = 'Offline';
                        }
                        const normalizedStatus = status.replace(/\s/g, '_').toLowerCase(); // Normalize for consistent keys
                        statusCounts[normalizedStatus] = (statusCounts[normalizedStatus] || 0) + 1;
                    }
                });

                // Update charts
                updateResponseTimeChart(timestamps, responseTimes);
                updateStatusDistributionChart(statusCounts);

                // Populate table (newest at top)
                // Need to reverse again for the table if charts consumed them in order
                // Or better, iterate original dataLines in reverse for table
                const tableDisplayLines = dataLines.reverse().slice(0, MAX_ROWS_TO_DISPLAY); // Re-reverse for table to show newest first
                tableDisplayLines.forEach(line => {
                    const columns = line.split(',');
                    if (columns.length === 5) {
                        const row = tableBody.insertRow();

                        row.insertCell(0).textContent = columns[0]; // Timestamp
                        row.insertCell(1).textContent = columns[1]; // Target URL
                        row.insertCell(2).textContent = columns[2]; // HTTP Code
                        row.insertCell(3).textContent = parseFloat(columns[3]).toFixed(3); // Response Time (formatted)

                        const statusCell = row.insertCell(4); // Status Message
                        // Display "Offline" instead of "curl_error" for better user experience
                        const displayStatus = columns[4].toLowerCase() === 'curl_error' ? 'Offline' : columns[4];
                        statusCell.textContent = displayStatus;
                        statusCell.classList.add('status-' + columns[4].toLowerCase().replace(/\s/g, '_'));
                    }
                });

                document.getElementById('loading').style.display = 'none';
                document.getElementById('lastUpdate').textContent = `Last updated: ${new Date().toLocaleString()}`;
            } catch (e) {
                console.error("Error parsing data:", e);
                document.getElementById('error').textContent = `Error parsing data: ${e.message}`;
                document.getElementById('error').style.display = 'block';
                document.getElementById('loading').style.display = 'none';
            }
        }

        // Toggle Table Button Logic
        const toggleTableBtn = document.getElementById('toggleTableBtn');
        const monitorTableContainer = document.getElementById('monitorTableContainer');
        let isTableVisible = false; // Initial state

        toggleTableBtn.addEventListener('click', () => {
            if (isTableVisible) {
                monitorTableContainer.style.display = 'none';
                toggleTableBtn.textContent = 'Show Table';
            } else {
                monitorTableContainer.style.display = 'block';
                toggleTableBtn.textContent = 'Hide Table';
            }
            isTableVisible = !isTableVisible;
        });

        // Initial fetch and periodic refresh
        fetchData();
        setInterval(fetchData, 60000); // Refresh data every 60 seconds

        // Global error handler to suppress non-critical browser extension errors
        window.addEventListener('error', function(e) {
            // Suppress favicon.ico 404 errors and browser extension errors
            if (e.target && e.target.src && e.target.src.includes('favicon.ico')) {
                e.preventDefault();
                return false;
            }
            
            // Suppress message channel errors from browser extensions
            if (e.message && e.message.includes('message channel closed')) {
                e.preventDefault();
                return false;
            }
            
            // Log other errors for debugging
            console.warn('Non-critical error suppressed:', e.message);
        });

        // Handle unhandled promise rejections
        window.addEventListener('unhandledrejection', function(e) {
            // Suppress message channel errors from browser extensions
            if (e.reason && e.reason.message && e.reason.message.includes('message channel closed')) {
                e.preventDefault();
                return false;
            }
            
            // Log other promise rejections for debugging
            console.warn('Promise rejection handled:', e.reason);
        });
    </script>
</body>
</html>